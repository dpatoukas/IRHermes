

HRMrecv::HRMrecv (int recvpin)
{
	//IRrecv irrecv(recvpin);
	//irrecv.enableIRIn();
	resetHRM();
}

HRMrecv::HRMrecv (int recvpin, int blinkpin)
{
	
	resetHRM();

}

bool HRMrecv::deliver(int size, hermes_results *result)
{
	if (listenHRM() && (result->arrived == size) )
	{
		return true;
	}

	return false;
}

bool HRMrecv::listenHRM()
{
	IRrecv irrecv(11,13);
	irrecv.enableIRIn();

	//Check for HDR
	if(!rcvedHDR(irrecv)) return false;
	
	//Check for bits 
	if(!rcvedBITS(irrecv)) return false;
	
	//Check for trailer
	if(!rcvedTRL(irrecv)) return false;
	
	//Validate result 
	if(!deliverHRM()) return false;
	
	irrecv.resume();
	return true;
}

bool HRMrecv::rcvedHDR(IRrecv irrecv)
{
	if (listen_state == STATE_WAITING)
	{
		return getHermesHDR();
	}

	return false;
}

bool HRMrecv::rcvedBITS(IRrecv irrecv)
{
	if (listen_state == STATE_HDR)
	{
		return getHermesBITS();
	}

	return false;	
}

bool HRMrecv::rcvedTRL(IRrecv irrecv)
{
	if (listen_state == STATE_BIT)
	{
		return getHermesTRL();
	}

	return false;
}

bool HRMrecv::deliverHRM()
{
	if (listen_state == STATE_TRAIL)
	{
		for (int i = 0; i <((int) buffer_pos); i++)
		{
			result->deliver[result->rcvd_pos++] = result->rcvd_buffer[i];
			result->arrived++;
			// #ifdef DEBUG
			//  	Serial.println("Arrived:%d", result->arrived);
			// #endif
		}
		
		if (result->rcvd_pos > MAX_BUFFER)
		{
			listen_state = STATE_OVER;
			resetHRM();
			return false;
		}
		
		resetHRM();
		return true;
	}

	return false;	
}

void HRMrecv::resetHRM()
{
	//listen_params_t parameters;
	listen_state = STATE_WAITING;
	parameters.buffer_pos = 0;
	
	result->arrived = 0;
	result->index = 0;
}